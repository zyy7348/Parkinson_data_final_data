---
title: "p8105 hw5 yz3300"
author: "Yeyi Zhang"
date: "11/5/2017"
output:
  html_document:
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(janitor)
library(tidyverse)
library(httr)
library(forcats)
library(viridis)
library(tidytext)
library(stringr)
library(rvest)

theme_set(theme_bw() +
          theme(legend.position = "bottom"))  

knitr::opts_chunk$set(
  fig.width = 8,
  fig.asp = .7,
  out.width = "90%"
)


```

## Problem 1

Using the State of New York API, read the complete dataset using functions in `httr`. 

```{r read data, warning=FALSE, message=FALSE}

ny_state = GET("https://data.ny.gov/resource/hvwh-qtfg.csv", query = list(`$limit` = 2000)) %>% 
  content("parsed") 

```

Clean it up: retain variables on station name, entrance latitude and longitude, East/West street, North/South street, and corner.

```{r tidy data}

ny_state_tidy = ny_state %>% 
  clean_names() %>% 
  select(station_name, entrance_latitude, entrance_longitude, east_west_street, north_south_street, corner)

```

Make a plot showing the number of entrances for each subway station. Restrict your plot to stations that have more than 10 entrances, and order stations according to the number of entrances.

```{r}

ny_state_tidy %>% 
  group_by(station_name) %>% 
  summarize(station_number = n()) %>%
  filter(station_number > 10) %>% 
  mutate(station_name = fct_reorder(station_name, station_number)) %>% 
  ggplot(aes(x = station_name, y = station_number)) + 
  geom_col(fill = "blue", alpha = .6) +
  labs(
    title = "Number of entrances for each subway station",
    x = "Station",
    y = "Number of entrances"
  ) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

```

* Overall, how many subway station names contain the abbreviation “St”? How many end with “St”?

```{r}

number = ny_state_tidy %>% 
  filter(str_detect(station_name, "St")) 

num_end = ny_state_tidy %>%
  filter(str_detect(station_name, "St$"))

```

There are `r length(unique(number$station_name))` subway station names contain the abbreviation “St”. And there are `r length(unique(num_end$station_name))` station names end with “St”.

## Problem 2

Find how many people watched each episode of “Game of Thrones” over the past 7 seasons online and import them into R using functions in `rvest`.

```{r import the data}

url = "https://en.wikipedia.org/wiki/Game_of_Thrones#Viewer_numbers"

watch_got_xml = read_html(url)
watch_got_table = (watch_got_xml %>% html_nodes(css = "table"))[[4]] %>% 
  html_table() %>% 
  .[,-13] %>%
  .[,-1] %>% 
  as_tibble() 

```

Read and tidy the data.

```{r read tidy}

watch_got_tidy = watch_got_table %>% 
  clean_names() %>% 
  rename(season = season_1) %>% 
  gather(key = episode, value = viewers, ep_1:ep_10) %>% 
  mutate(episode = str_replace(episode, "ep_", "E0"),
         episode = str_replace(episode, "E010", "E10"),
         episode = factor(episode),
         episode_id = paste("S", season, episode, sep = "_"),
         episode_id = str_replace(episode_id, "S_", "S"),
         viewers = as.numeric(viewers),
         season = as.character(season)) %>% 
  filter(!is.na(viewers))

```

Make a plot that shows the number of viewers for each episode of each season.

```{r plot}

watch_got_tidy %>% 
    ggplot(aes(x = episode_id, y = viewers, fill = season)) +
    geom_col(aes(group = season)) +
  labs(
    title = "U.S. viewers for each episode",
    x = "Episode",
    y = "Viewers(millions)"
  ) +
  theme(axis.text.x = element_text(angle = 90)) 

```

Make a boxplot of the number of viewers for each episode of each season.

```{r boxplot}
watch_got_tidy %>% 
    ggplot(aes(x = season, y = viewers)) +
    geom_boxplot() +
  labs(
    title = "U.S. viewers of each season",
    x = "season",
    y = "Viewers(millions)"
  ) 
```

Fit a linear model that treats number of viewers in each episode as a response and season as a categorical predictor; make season 4 the reference season. Present and discuss the results of your modeling.

```{r}

watch_got_lm = watch_got_tidy %>% 
  mutate(season = factor(season),
         season = fct_relevel(season, "4")) 

watch_got_lm %>% 
  lm(viewers ~ season, data = .) %>% 
  broom::tidy() %>% 
  select(-std.error, -statistic) %>% 
  knitr::kable(digits = 3)

```

From both the table and the plot we can see that there is no significant difference between viewers of season four and season five and there is significant difference between season four and season one, two, three, six and seven, respectively.

## Problem 3

The reviews of the movie “Napoleon Dynamite” from Amazon includes `title`, `stars` and `text` variables. The scraping is successful after running the code from the website.

Here we use the download version of the data tp prevent large numbers of requests from a single computer.

```{r}

dynamite_reviews = read_csv("./data/dynamite_reviews.csv") %>% 
  clean_names() %>% 
  rowid_to_column(var = "dynamite_num") 

```

Create a tidy text dataset from the above using the text in the reviews. Use words as the token and remove stop words.

```{r}
data(stop_words)

dynamite_reviews_words = dynamite_reviews %>%
  unnest_tokens(word, text) 

dynamite_reviews_words = anti_join(dynamite_reviews_words, stop_words) 
```


* What words are most frequently used in five-star reviews? In 1-star reviews?

```{r}

word_freq_five = dynamite_reviews_words %>%
  filter(stars == "5") %>% 
  count(word, sort = TRUE) %>% 
  top_n(1) 

word_freq_one = dynamite_reviews_words %>%
  filter(stars == "1") %>% 
  count(word, sort = TRUE) %>% 
  top_n(1) 

```

The word `r word_freq_five$word` is the most frequently used in five-star reviews and also in one-star reviews.

Make a plot that shows the (approximate) log odds ratio for word appearance comparing 1-star reviews to 5-star reviews; include the 10 words with the most extreme log ORs in both directions.

```{r}

word_ratios = dynamite_reviews_words %>%
  filter(stars %in% c(1, 5)) %>% 
  count(word, stars) %>% 
  spread(stars, n, fill = 0) %>%
  mutate(
    one_odds = (`1` + 1) / (sum(`1`) + 1),
    five_odds = (`5` + 1) / (sum(`5`) + 1),
    log_OR = log(one_odds / five_odds)
  ) %>%
  arrange(desc(log_OR)) 

word_ratios %>%
  mutate(pos_log_OR = ifelse(log_OR > 0, "1-star > 5-star", "5-star > 1-star")) %>% 
  group_by(pos_log_OR) %>% 
  top_n(10, abs(log_OR)) %>%
  ungroup() %>%
  mutate(word = fct_reorder(word, log_OR)) %>%
  ggplot(aes(word, log_OR, fill = pos_log_OR)) +
  geom_col() +
  coord_flip() +
  ylab("log odds ratio (1-star/5-star)") +
  scale_fill_discrete(name = "")

```

Conduct a sentiment analysis of the review texts. 

```{r}
bing_sentiments = get_sentiments("bing")

dynamite_sentiments = dynamite_reviews_words %>% 
  inner_join(., bing_sentiments) %>% 
  count(dynamite_num, sentiment) %>% 
  spread(sentiment, n, fill = 0) %>% 
  mutate(sentiment = positive - negative) %>% 
  select(dynamite_num, sentiment)

dynamite_sentiments = 
  right_join(dynamite_reviews, dynamite_sentiments, 
             by = "dynamite_num")

```

Make a plot of your results and include the star rating in your graphic. 

```{r}

dynamite_sentiments %>% 
  mutate(dynamite_num = factor(dynamite_num),
         dynamite_num = fct_reorder(dynamite_num, sentiment),
         stars = as.character(stars)) %>% 
  ggplot(aes(x = dynamite_num, 
             y = sentiment, fill = stars, color = stars)) + 
  geom_bar(stat = "identity") + 
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank()) +
  scale_fill_viridis(discrete = TRUE) + 
  scale_color_viridis(discrete = TRUE) 

```

* What is the most positive review? The most negative review?

The most positive review is:

```{r}

dynamite_sentiments %>%
  arrange(desc(sentiment)) %>% 
  top_n(1) %>% 
  select(-dynamite_num, -sentiment) %>% 
  knitr::kable() 

```

The most negative review is:

```{r}

dynamite_sentiments %>%
  arrange(desc(sentiment)) %>% 
  top_n(-1) %>% 
  select(-dynamite_num, -sentiment) %>% 
  knitr::kable()

```

